

1. Общая концепция

По исходному скрипту компилер создает Си-код: декларацию, обычно помещаемую в 
заголовочный файл, и дефиницию, содержащию инициализирующий код.
Таким образом, после запуска приложения, все данные уже автоматически проинициализированы.


2. Запуск с командной строки

XPrm.exe	<file.prm>  -Fo<file.bpr> -Sd

file.prm -  собственно скрипт
file.bpr - факе бинари для студии, чтобы правильно определять изменения файла

Sd - "supress definition update" - не обновлять дефиниции, если не было изменений структуры (деклараций)
То же самое можно получить, создав рядом с XPrm.exe XPrm.ini c ключевым словом внутри: 
	supress_definition_update
Этот режим нужен, если интенсивно изменяются параметры, чтобы не тратить время на ребилд.


3. Секция

состоит из заголовка и тела

section ForceFieldPrm ( declaration = "VisGeneric\client\ForceField.h", definition = "VisGeneric\client\ForceField.cpp" )
{
}

только то, что внутри секции, будет перенесено в Си-исходник
В одном prm-файле может быть несколько секций. 
У секции должно быть уникальное имя.
В именах файлов в заголовке секции писать одиночный слэш (\), в то время, как внутри секции при определении
строк, следовать стандартному Си-синтаксису, получая в распоряжение непечатные символы.

Необязательные параметры заголовка: 

source = "Scripts\ForceField.prm"
Путь до скрипта. По умолчанию он расчитывается от текущего пути при компилляции и прописывается в дефиницию для того, чтобы 
при запуске можно было перезагрузить данные, если дата скрипта больше, чем дата компилляции (также прописывается в дефиниции)

using_namespace
Содержимое секции кладется в пространство имен с именем секции.


4. Базовые типы 

int i = 1;
float f = 1.;
double d = 2.;
string s = "jdcdubc\n";  // -> char*
Vect3f v = { 1, 2, 3 }; // в Си-коде должен быть включен xmath.h и их нельзя вставлять в структуры

5. Массивы

base_type array_name[] = { element0, element1, element2 ...}; 
base_type array_name[array_size] = { element0, element1, element2 ...}; 

Во втором случае будет создана дополнительно целочисленная переменная array_size с реальным размером массива

6. Структуры

struct StructName
{
	int i = 1;
	float ff[] = { 1, 2 };
	double dd[dd_size] = { 1, 2 }; 
};

StructName struct_data1 = {}; 
StructName struct_data2 = { i = 2; }; // Уточняющий assignment-код




////////////////////////////////////////////////////////////////////////
//						Версии
////////////////////////////////////////////////////////////////////////

1.03:
1. Баг с компилляцией из либа
2. [имя_размера_массива]
3. Enum, определенный внутри секции портиться в декларацию

1.04
1. Баг с noname enum's.
2. Enum внутри структур

1.05 
Декларация массивов с константным размером для возможности использования их в структурах

1.06
Баг с компилляцией инклудов в либах

1.07
Псевдопеременные массивы в структурах
Полный путь при выводе ошибки компилляции

1.08
Присваивание enum'ам целых переменных и других enum'ов

1.09
Ключевое слово script_path в заголовке секции заменено на source
Ключевое слово delegate: в структуре переносит весь нижестоящий код в Си без изменений и анализа (кроме контроля 
вложенности {} с учетом комментариев).

1.10
reload_scripts() - для использования внешнего редактора скриптов
проверка на присваивание переменной из вышестоящего контекста (локальность присваивания)

1.11
запрет на переопределение переменных

1.12
баг с переопределением вложенных структур при наследовании.
арифметические выражения:
int: -,();  *,/;  +,-;  <<,>>;  &;  ^;  |
double, float: -,();  *,/;  +,- 	(все вычисления ведутся в double)
string: +

1.13
обновление декларации всегда приводит к обновлению дефиниции

1.14 
баг с массивами нулевого размера

1.15
Возможность инициализировать структуры именем структуры или уже созданным элементом:
StructName s[] = { {}, StructNameDerived {}, struct_element {}};

1.16
Доступ к элементам структур и массивов как за значениями, так и для присваивания. В последнем случае 
контролируется однократность присваивания и контекст присваивания (должен быть текущим).

1.17
typedef
Vect3d
Исправлен баг с паковкой структур (проявлялся при использовании double)

1.18
static - перед типом указывает, что этот объект не будет декларироваться.

1.19
fix out of XBuffer

1.20
учет include при загрузке

1.21
Разрешение определения элементов структур без обязательного ранее блока { }.

1.22
При подписывании теперь используется только имя прм-файла или инклуда _без_ _пути_.

1.23	18.10.2002 17:23:09
Строгое использование именованых перечислений, в том числе с вложенностью в структуры:

struct AAA { enum E { a, b, c }; };
AAA::E ae[] = { AAA::b, AAA::b, AAA::c };

1.24	24.10.2002 16:00:23
Исправлен баг с вводом специальных символов в строковых переменных.


1.25	29.10.2002 11:25:42
Присваивание enum to enum:
AAA::E x = AAA::a;
AAA::E y = x;

Статические структуры - для структурирования статических (скрытых данных).
Они не будут транслированться в cpp/h. Их элементы должны тоже объявляться статическими.

Баг со специфицирующей конструкцией:
Struct s = {...};
Struct s1 = s {...};

Баг с неперехваченными исключениями.

1.26    10.12.2002 0:13:08
Допускается static перед enum.

1.27	05.03.2003 13:19:16
Баг с присваиванием структуры самой себе. Такая конструкция нужна для многократного 
уточнения значений.

1.28	14.03.2003 22:02:01
Явное задание максимального размера массива:
type array[real_size = max_size] = {};
т.к. в большинстве случаев массив по умолчанию пустой (real_size = 0), это уменьшает скрипт.
Неинициализированные элементы будут инициализироваться 0, "".
И к ним нельзя будет обратиться посредством индексации [] при переопределении в производных структурах.
max_size - целочисленное выражение.

1.29	15.03.2003 13:08:17
Требование явной декларации (int) переменной реального размера массива:
type array[int real_size = max_size] = {};
Возможные варианты синтаксиса:
Type array[int real_size] = {}; // максимальный размер определяется по перечислению
Type array[max_size] = {}; // нет переменной реального размера
Type array[] = {}; // нет переменной реального размера и определение по перечислению

1.30	25.03.2003 13:59:28
Указатели - для экономии места и реализации ссылок:
Type* pointer = 0;
Type* pointer = &object;
Type* pointer = new Type {};
Type* pointer = new Type[] { {}, {} };
Type* pointer = new Type[int real_size] { {}, {} };
Type* pointer = new Type[int real_size] {}; // real_size = 0; pointer = 0;
Все данные лежат в статической памяти (при new генерируется уникальное имя).
Индексировать new-массивы для r-value запрещено, так как небезопастно.
Не имеет смысла задавать максимальный размер 
Type* pointer = new Type[int real_size = max_size] { {}, {} }; // запрещенная конструкция

Значительное увеличение производительности


1.31	08.04.2003 12:35:01
Инициализация строк нулем.
Переход на декларацию строк как char const*.

1.32	14.04.2003 16:25:53
Баг с вложенными указателями

1.33	02.05.2003 17:37:04
Останавливает компилляцию посредством генерации ошибки,
если было изменение в cpp/h

1.34	12.05.2003 15:00:56	
Откат остановки компилляции.
Создает файлы, если их нет.
Убраны типы Vect3f и Vect3d.
Исправлен баг с \n.


1.35	21.05.2003 13:07:30
Убрана проверка на дату. Перегружает всегда, если не _FINAL_VERSION_

1.36	23.05.2003 17:35:26
Проверка времени для force_update

1.37	16.07.2003 14:20:22
Переход в хеш-мапе на строки. (Портились данные)

1.38	17.07.2003 10:30:02
Перезагрузка по CRC

1.39	18.07.2003 14:54:00
Баг с нулевыми строками

1.40	19.07.2003 21:22:06
check_updata

